package com.seccertificate.api.service;

import com.seccertificate.api.domain.Certificate;
import com.seccertificate.api.dto.VerificationResultDto;
import com.seccertificate.api.repository.CertificateRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class VerificationService {

    private final CertificateRepository certificateRepository;
    private final CertificateSignatureService signatureService;

    public VerificationResultDto verify(String hash) {

        log.info("Verification request received for hash: {}", hash);

        return certificateRepository.findByVerificationHash(hash)
                .map(cert -> {

                    log.info("Certificate FOUND");
                    log.info("Certificate ID: {}", cert.getId());
                    log.info("IssuedTo: {}", cert.getIssuedTo());
                    log.info("CreatedAt: {}", cert.getCreatedAt());
                    log.info("Status: {}", cert.getStatus());
                    log.info("Template: {}", cert.getTemplate() != null ? cert.getTemplate().getName() : "null");
                    log.info("Customer: {}", cert.getCustomer() != null ? cert.getCustomer().getName() : "null");

                    boolean signatureOk = signatureService.verify(cert);

                    if (!signatureOk) {

                        log.error("VERIFICATION FAILED — CERTIFICATE TAMPERED OR INVALID");
                        log.error("Hash: {}", hash);

                        return VerificationResultDto.builder()
                                .valid(false)
                                .tampered(true)
                                .message("Certificate data has been tampered with or signature is invalid.")
                                .verificationHash(hash)
                                .issuedTo(cert.getIssuedTo())
                                .issuedAt(cert.getCreatedAt())
                                .status(cert.getStatus())
                                .templateName(cert.getTemplate() != null ? cert.getTemplate().getName() : null)
                                .customerName(cert.getCustomer() != null ? cert.getCustomer().getName() : null)
                                .build();
                    }

                    log.info("VERIFICATION PASSED — CERTIFICATE LEGIT");

                    return VerificationResultDto.builder()
                            .valid(true)
                            .tampered(false)
                            .message("Certificate is valid and was generated by Sec CERTIFICATE.")
                            .verificationHash(hash)
                            .issuedTo(cert.getIssuedTo())
                            .issuedAt(cert.getCreatedAt())
                            .status(cert.getStatus())
                            .templateName(cert.getTemplate() != null ? cert.getTemplate().getName() : null)
                            .customerName(cert.getCustomer() != null ? cert.getCustomer().getName() : null)
                            .build();
                })
                .orElseGet(() -> {

                    log.warn("NO CERTIFICATE FOUND for hash: {}", hash);

                    return VerificationResultDto.builder()
                            .valid(false)
                            .tampered(false)
                            .message("No certificate found for this verification hash.")
                            .verificationHash(hash)
                            .build();
                });
    }

}
